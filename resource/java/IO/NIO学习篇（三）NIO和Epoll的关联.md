## NIO学习篇（三）NIO 和 Epoll 的关联

写在前面：本文转载于： <a href="https://www.jianshu.com/p/dc1acbc7e130">NIO&epoll</a>      作者：软萌白甜Hedy


 说到NIO，涉及到的知识点有很多，我们来一一捋一捋。

**1、IO介绍**

IO(InputStream/OutputStream)指的是读出/写入数据，IO可以分为磁盘IO和网络IO，围绕我们今天主题讲的是

网络IO。网络IO包括了等待数据传输和数据读写的过程，等待数据传输其实就是等待数据经由网线，网卡，内核

控件的传输的过程，读写数据的过程就是内核空间和用户空间之间数据相互拷贝的过程。

举个例子，在I/O的read发生时，跟关键的两点：

1. 等待数据准备
2. 将数据从内核空间空间拷贝一份到用户空间，然后用户程序处理数据。

正如万事万物不是你想要的时候就有的一样，当从内核空间想要拿取数据时，可能数据数据不存在。这时只能等待

数据读取传输到到内核地址空间，而此时用户程序也因此二阻塞。当内核空间上数据准备好了之后，操作系统便会

将数据拷贝一份到用户地址空间，然后告诉用户进程数据准备好了，用户进程解除阻塞状态，重新运行起来。



**2、Socket介绍**

Java中的网络通信都是有Socket（套接字）实现的 ，相信大家都舒心TCP/IP协议，Http协议等协议，Socket是

TCP/IP的一个具体的实现。Socket分为ServerSocket和Socket两类，ServerSocket用于服务端，可以通过方法监

听客户端的请求，坚定到请求后返回一个Socket实例对象，用于完成具体的数据传输；而Socket适用于客户端发

起请求和数据传输的。说白了，网络I/O就是通过Socket来进行通信的。



**3、获取通信数据**

Socket是我们传输数据的工具，那我们如何得知已传输的数据呢？数据经由网线传输过来，第一步先打到我们电

脑的网卡，然后控制网卡的驱动（网卡驱动程序就是CPU控制和使用网卡的程序）开始发挥作用，发起中断请求告

知CPU数据已到达的信息。

**中断**允许让设备，如键盘，串口卡，并口等设备表名它们需要CPU。一旦CPU相应中断请求，CPU就会暂时停止正

在执行的程序，并调用一个成为**中断服务程序（interrupt service routine）**的待定程序，维护线程。之后CPU

会恢复之前被中断的程序。那么接下来会发生什么？内核空间还在等着它需要的数据呢，我们继续往下走。



**4、阻塞**

操作系统已经知道数据来到了。现在我们进入内核地址空间，操作系统为实现进程调度，会把进程分为“运行”、

“等待”等几种状态。**运行**的金成功能轮流的获取CPU的资源，而”等待“其实不理解。回溯一下，我们前文里一直在

说的就是等待网络数据的到来，很好理解，拥有CPU资源的当前进程执行到创建Socket语句时，操作系统会创建

一个有文件系统管理的Socket对象，该对象包含了接受数据的缓冲区，发送数据的缓冲区，等待队列（**指向所有**

**需要等待该socket对象接受到的数据的进程**）。创建完socket对象之后，操作系统会继续执行，到执行到recv方

法时（**无论是客户端还是服务端应用程序都会用recv函数从TCP连接的另一端接受数据），如果数据还未到达，

则当前进程会给阻塞，然后加入到socket维护的等待队列里。

此时，可能你会疑问？操作系统如何知道数据到底对应的是哪个socket？我们知道网络传输的数据都会包含IP和端

口号，操作系统会给每一个socket对象的索引维护一个端口号以便快速读取，内核通过端口号就能快速找到对应的

socket。

阻塞一般是使用等待队列实现的，等待队列维护进程的引用。操作系统进程停止在此处（recv方法调用）并睡眠下

，知道苏醒条件都满足时，操作系统才换唤醒进程，进行运行。在等待的睡眠期间，wake up时，检查条件，如条

件满足，则唤醒进程，反之继续睡眠。

总结一下2,3,4说的过程：

1. 进程等待数据：进程A拥有CPU资源，当它执行创建socket语句时，生成一个socket实例对象（包好接受数据

   的buffer，发送数据的buffer，等待队列），然后执行执行到recv方法时，没有检测到数据，操作系统将进程

   A睡眠（阻塞），并由工作队列移到socket维护的等待队列中，其他进程轮流执行。

2. 数据到来：网络数据经由网卡传入内存，网卡驱动发出中断请求，CPU做出相应，执行中断程序，socket接收

   到数据，将数据传入到内核，并拷贝一份到用户空间。

3. 唤醒进程：socket接收到数据后，操作系统将socket维护的等待队列中的进程A唤醒，并移出等待队列，进程

   回到工作队列中继续执行代码，进程通过recv方法获取到socket接受到数据。

上面完整梳理了内核接收数据的全过程，但你有发现问题吗？如何做到监视全部的socket？



**5、select函数**

任何事情都不能一蹴而就，解决问题先从最笨的方法开始——操作系统提供select函数。select函数机制的思路是

：维护以租fds的数据，用于存放全部所需要监视的socket对象，socket在等待数据时，进程别挂起，socket接受

到数据后，相应的进程会被操作系统唤醒，继续执行。看起不难，再重新捋一下内核接受数据的过程：

1. 进程等待数据：进程A拥有CPU资源，当它执行创建socket语句时，生成一个socket实例对象（包好接受数据

   的buffer，发送数据的buffer，等待队列），然后执行执行到recv方法时，没有检测到数据，操作系统将进程

   A睡眠（阻塞），并由工作队列移到socket维护的等待队列中，其他进程轮流执行。同时调用select函数将

   socket移到select函数机制维护的fds数组中。

2. 数据到来：网络数据经由网卡传入内存，网卡驱动发出中断请求，CPU做出相应，执行中断程序，socket接收

   到数据，将数据传入到内核，并拷贝一份到用户空间。

3. select函数返回数据可读标识，进程A被操作系统唤醒，继续执行。

值得注意的是：

当调用到select函数时，内核会先遍历一遍fds数组，如果有socket的接收缓冲区有数据时，那么select函数会直接

方法，进程A不会阻塞。这也就是select的返回值有可能大于一的原因之一。如果所有socket都没有数据，阻塞进

程A。

监视所有的socket是做到了，又有新的问题来了：如何得知是哪个socket接收了数据，是需要重新遍历一下fds数

组的。然后遍历socket维护的等待队列，唤醒队列中被阻塞的进程。这样总共需要就需要遍历三次数组（两次遍历

fds，一次遍历socket维护的等待队列[还有可能是多个socket是有数据的 ]）。这样是很耗时的。所以，不用我再

明说，你肯定知道了，接下来，是这个系统需要再次进化的时候了。



**6、epoll函数**

Select遍历次数多，开销大的原因有以下两点：

①：socket维护的等待队列和阻塞进程关联在了一起

②：需要遍历fds数组（维护所有socket的数组）才能知道接受数据的socket

解决方案：

对于第一点：采用懈偶（功能分离）

将socket维护的等待队列和阻塞进程分离开。当程序执行到recv方法时，在操作系统调用的epoll函数中，使用

epoll_create函数创建一个epoll对象epdf（文件系统的一员，有等待队列），然后使用epoll_ctl函数将需要监视

socket加入到epdf对象中的监视列表，再使用epoll_wait函数接受数据，同时阻塞进程A，然后将进程A加入到

epdf的等待队列中。

对于第二点：采用就绪列表维护

epoll对象维护了一个redlist，rdlist维护接收到数据的socket对象。这样就避免为寻找接收到数据的socket对象而

出遍历全部租soket的低效。进程被唤醒 后，只要获取rdlist的socket引用，就能获取到搜才socket接收到的数据



epoll对象epdf创建的过程：

1. 创建epoll对象epdf：当某个进程调用epoll_create方法时，内核会创建一个epoll对象epdf（eventpoll），

   epdf和socket一样是文件系统中的一员，也有等待队列，还维护了rdlist作为它的成员。

2. 维护监视列表：创建epoll对象后，epoll_ctr方法可以添加和删除监听的socket对象，内核将epdf需要的

   socket加入到监视列表中。所以socket接受数据后，中断程序会直接操作epdf对象，而不是阻塞进程。

3. 接受数据：当监视列表中的socket接受到数据后，中断程序会将socket（接收到数据的）的引用放入到rdlist

   列表中。epdf（eventpoll）相当于socket和阻塞进程的中介，socke接受到数据并不会影响到阻塞进程，而是

   通过rdlist来更改阻塞进程的状态。rdlist有socket引用，epoll_wait返回；rdlist为空，进程A继续阻塞。

4. 阻塞和唤醒进程：进程运行到epoll_wait方法时，内核会将进程加入到epdf（eventpoll）维护的等待队列中。

   socket接受到数据后，中断程序会做两件事情：①：将接受到数据的socket的引用加入到rdlist中。②：唤醒

   等待队列中的阻塞进程

epoll值得配图一张，引用自知乎罗培羽:

![img](https://upload-images.jianshu.io/upload_images/5868227-9d600bd171252017.png?imageMogr2/auto-orient/strip|imageView2/2/w/1040/format/webp)



**7、值得思考的两个问题**

1. rdlist的数据结果

   需要满足的提交时：能够快速添加socket，而且epoll_ctl方法还有监听，同时可能需要的频繁的添加、删除

   socket引用，无疑是双向链表最为合适。

2. 索引结构

   因为要将维护等待队列和进程阻塞分离，所以需要一个便于监听管理socket的数据结构，需要满足便于查找，

   防止重复添加，方便删除的数据结构，之前二叉树家族的文章里讲过的数据结构很满足这个要的是红黑树，红

   黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树

   作为索引结构（TreeSet）。

**8、NIO及epoll**

**NIO**(new IO) ，这个new是相当于BIO来说的，BIO（Blocking IO）是同步阻塞式IO，服务器实现模式为一个链接

一个线程处理，即客户端有链接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不

必要的线程开销。为了降低开销的问题，就产生了NIO，同步非阻塞式IO，服务器实现模式为一个请求一个线程，

即客户端发送的连接都会注册到**多路复用器（selector）**上，多路复用器轮询到连接有I/O请求时才会启动一个线

程进行处理。

**epoll**是在select的基础上，改良了几个不够高效的点，引用了先进的数据结构，实现了更高效的多路复用。
