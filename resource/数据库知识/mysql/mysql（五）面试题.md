##  mysql （五）面试题

#### 1、前言

mysql 数据库知识，学习到这，个人感觉差不多了，以后有需要，再去学习，做记录。想着现在一个 offer 都没有，总需要刷刷面经的吧，遂而总结一下，mysql 数据库方面的面试问题。

#### 2、正文

> 以下内容多参考于：<a herf="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484617&idx=1&sn=afddfe5c3d66a9fcaba65516a0ab5d18&chksm=96f666a0a181efb60f2109714cf34f4bc68e424ed364d15375284b23f81259e8181c60f7ad10&mpshare=1&scene=23&srcid=0221PWQc3toH5tYYN2zhxiDa&sharer_sharetime=1582269315101&sharer_shareid=a8ee705dc28d6aaab271b797da5bc9c5#rd">面试官:mysql表设计要注意什么？</a>和 <a herf="https://mp.weixin.qq.com/s?__biz=MzIwMDgzMjc3NA==&mid=2247484720&idx=1&sn=7bd7774058e7886eeb3dedb38aa8657a&chksm=96f66759a181ee4f4c177a755c3ac6b6e97fef148bbf4afea8616f4edec33bf6d4f18cda9f69&mpshare=1&scene=23&srcid=&sharer_sharetime=1582269373590&sharer_shareid=a8ee705dc28d6aaab271b797da5bc9c5#rd">面试官:谈谈你对mysql索引的认识？</a>

* mysql 在建立表时，为啥一定需要设一个主键？

  因为在不设置主键的情况下，innodb 引擎也会自主生成一个隐藏列，作为自增主键。所以还不如自主设置一个主键，还能显示使用主键索引，提高查询效率。

  

* 当自增主键用完时，怎么办？

  ①：修改为 BigInt 类型（不推荐），使用 *alter* 修改字段值，修改时，会产生一个临时表，将数据存放到临时表中，然后修改完之后，将数据放回到原表中，此过程是原表是不可操作的，即不能读写。

  ②：自增主键用完，那就意味着，数据已经到达了 18亿条记录，当然是分库分表了。 

  

* 如何分库分表？

  分区（磁盘物理上的分区） > 垂直分库（将数据拆分成多个数据库，将冷热表分化成库）> 水平分库（有多个一样的数据库） > 垂直分表（将表的冷热字段划分成表）> 水平分表（一个库有多个相同的表）

  

* 主键是选择 自增 还是 UUID？

  选择自增的。innodb 中的主键是聚簇索引，如果主键是自增的，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果是非自增的话，那么可能会在中间插入，就会引发页的分裂，产生很多表碎片。

  

* 主键为啥不推荐设置有业务含义的？

  * 因为含有业务意义的字段，有可能会发生变更，主键字段一旦含有业务含义，那么主键就有可能发生变更。而 mysql 一般都是以主键建立聚簇索引的，一旦主键发生变更，该数据在磁盘上的存储位置就会发生变更，有可能会引发页分裂，产生空间碎片。

  * 含有业务意义的主键，一般不为自增类型，在增加数据的时候，就可能引发页的分裂，产生空间碎片。

    

* 表示枚举字段为啥不用 enum 类型？

  一般会将枚举类型设置为 *tinyint* 类型。不用 enum 类型，有以下两个原因：

  (1)ENUM类型的ORDER BY操作效率低，需要额外操作。

  (2)如果枚举值是数值，有陷阱。

  举个例子，如下：

  ```sql
  #表结构：
  CREATE TABLE test (foobar ENUM('0', '1', '2'));
  
  # 插入语句
  mysql> INSERT INTO test VALUES (1); #个人测试是可以通过的
  ```

  *select count(1) from test* ;		则查询出的结果为：（就产生了一个坑爹的结果）：0


  插入语句应该像下面这么写，插入的才是 1

  ```
  mysql> INSERT INTO test VALUES (`1`);
  ```

  

* 货币字段用啥类型？

  * 如果单位为元，则使用 *Decimal* 类型。
  * 如果单位为分，则可以使用 *Int* 类型。
  * 如果是 *Float* 和 *Doubble* 类型，会发生精度失准。

* 时间字段有啥类型？

  * *varchar*：如果用varchar类型来存时间，优点在于显示直观。但是坑的地方也是挺多的。比如，插入的数据没有校验，你可能某天就发现一条数据为 *2013111* 的数据，请问这是代表2013年1月11日，还是2013年11月1日？其次，做时间比较运算，你需要用 *STR_TO_DATE* 等函数将其转化为时间类型，你会发现这么写是无法命中索引的。数据量一大，是个坑！

  * *rimestamp*：该类型是四个字节的整数，它能表示的时间范围为1970-01-01 08:00:01到2038-01-19 11:14:07。2038年以后的时间，是无法用 *timestamp* 类型存储的。

    但是它有一个优势，`timestamp`类型是带有时区信息的。一旦系统中的时区发生改变，例如修改了时区

    ```sql
    SET TIME_ZONE = "america/new_york";
    ```

    你会发现，项目中的该字段的值自己会发生变更。这个特性用来做一些国际化大项目，跨时区的应用时。

  * *datetime*：储存占用8个字节，它存储的时间范围为 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。显然，存储时间范围更大。但是它坑的地方在于，存储的是时间绝对值，不带有时区信息。如果你改变数据库的时区，该项的值不会自己发生变更！

  * *bigint*：也是8个字节，自己维护一个时间戳，表示范围比 *timestamp* 大多，就是要自己维护，不大方便

    

* 为什么表直接存放存储图片，音频，视频等大文件内容？

  在实际开发，都是用 *HDFS* 来存储文件。然后 mysql 中，只存文件的存放路径。mysql 中有两个字段类型被用来设计存放大容量文件，也就是 *text* 和 *blob* 类型，但不推荐使用这两个类型！

  主要原因有如下两点

  - mysql 内存临时表不支持 *text、blob* 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行，导致查询效率缓慢。

  - *binlog* 内容太多，因为数据内容比较大，就会造成 *binlog* 内容增大。*binlog* 太大了，就会导致主从同步效率问题！

    

* 字段为啥要定义为 NOT NULL？

  - 索引性能不好 ：mysql 难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。—— 出自《高性能mysql第二版》      

  - 查询会出现一些不可预料的结果。有时候 *count（）* 函数不会统计 null 类型的记录。    

    

* 怎么建立索引？

  先尝试优化 sql，然后根据情况时候建立索引，例如只需一条记录，则在后面使用 *limit 1*，增加性能，告诉 mysql 不要再继续查询了。

  建立索引规则：

  - 索引并非越多越好，大量的索引不仅占用磁盘空间，而且还会影响 insert,delete,update 等语句的性能
  - 避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。同时对经常用于查询的字段创建索引，避免添加不必要的索引
  - 对数据量少的表尽量不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果
  - 尽量对字段上的是不同的值建立索引，在不同值很少的列上不要建立索引。比如性别字段只有 “男”“女” 俩个值，就无需建立索引，因为这样建立了索引不但不会提升效率，反而严重减低数据的更新速度。
  - 在频繁进行排序或者分组的列上建立索引，如果排序的列有多个，可以在这些列上建立复合索引。



* 讲讲索引的分类？你知道哪些？

  * 物理存储角度:
    	 聚簇索引和非聚簇索引
  * 数据结构角度:
     B+树索引、hash索引、FULLTEXT索引、R-Tree索引
  * 逻辑角度:
    * 主键索引：主键索引是一种特殊的唯一索引，不允许有空值
    * 普通索引或者单列索引
    * 多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用，使用复合索引时遵循最左前缀集合
    * 唯一索引或者非唯一索引
    * 空间索引：空间索引是对空间数据类型的字段建立的索引，mysql 中的空间数据类型有4种，分别是*GEOMETRY、POINT、LINESTRING、POLYGON*。

* 现在有一个列，里头的数据都是唯一的，需要建一个索引，选唯一索引还是普通索引？

  肯定是唯一索引。

  首先，在孤尽出的《阿里巴巴JAVA开发规范》中有这么一段话

  > 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
  >
  > 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。

  

* 为什么唯一索引的插入速度比不上普通索引？为什么唯一索引的查找速度比普通索引快？

  在进行非聚簇索引的 insert 时，先判断插入的索引页是否在内存中。如果在，则直接插入；如果不在，则先放入*Insert Buffer* 中，然后再以一定频率和情况进行 *Insert Buffer* 和原数据页合并 (merge) 操作。其目的是：:能将多个插入合并到一个操作中，就大大提高了非聚簇索引的插入性能。

  *innodb* 从 *1.0.x* 版本开始引入了 *Change Buffer*，可以算是对 *Insert Buffer* 的升级。从这个版本开始，*innodb* 存储引擎可以对 *insert、delete、update* 都进行缓存。

  唯一速度的 *insert* 比普通索引慢的原因就是:

  - 唯一索引无法利用 *Change Buffer*
  - 普通索引可以利用 *Change Buffer*

  唯一索引的 搜索速度 比普通索引快的原因就是:

  - 普通索引在找到满足条件的第一条记录后，还需要判断下一条记录，直到第一个不满足条件的记录出现。

  - 唯一索引在找到满足条件的第一条记录后，直接返回，不用判断下一条记录了。

    

* 为什么唯一索引的更新不使用 Change Buffer？
  因为唯一索引为了保证唯一性，需要将数据页加载进内存才能判断是否违反唯一性约束。但是，既然数据页都加载到内存了，还不如直接更新内存中的数据页，没有必要再使用 *Change Buffer*。

  

* mysql 某表建了多个单索引，查询多个条件时如何走索引的？

  这是优化器的事情了。mysql 在优化器中有一个优化器称为 Range 优化器，负责进行范围查询的优化！该优化器计算执行成本有两种方式 index dive 与 index statistics。这两个方式都是 mysql 优化器对开销代价的估算方法，前者统计速度慢但是能得到精准的值，后者统计速度快但是数据未必精准。

  

* sql 执行得慢的原因：

  * mysql 在根据 *redo log* 日志，更新磁盘的脏数据

  * 没有拿到锁

  * 没有走索引

    * 字段没有建立索引

    * 没有使用到索引

    * 使用索引的方式不对（在使用索引的时候，不能对建立索引的字段 使用函数操作或者运算）
    * 没有命中索引（在执行索引查询的时候，mysql 会随机扫描表上该字段值，如果字段上不同值的值越多，则 mysql 的索引区分度（基数）越高，越有可能使用索引，反之就有就有可能不走索引的）

  

  完结。

  

  

  

  

  

  

  

  ​                                                                    

  