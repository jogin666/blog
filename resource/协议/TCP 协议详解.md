## TCP协议回顾



### 一、运输层之间的通信

端到端的通信是主机之间的进程的通信

* 复用 ：发送方不同的应用进程都可以使用同一运输层协议传输数据（需要添加合适的报文首部）
* 分用 ：接收方在运输层把接受到的报文去除报文的首部后，能够把报文准确的交给进程



### 二、TCP协议的特点

* 是面向连接的运输层协议

  > 在发送用户数据报之前，必须要建立TCP 连接，数据传输完之后，必须释放连接。

* 点对点的通信

  > 每个连接只能有两个端点，一对一的通信

* 提供平可靠交付的服务

  > 通过 TCP 连接传输的数据，无差错，无丢失，不重复，并且是按序到达的。

* 提供全双工通信

  > 允许通信双方的应用进程在任何时候都可以发送数据。TCP 在发送方和接收方分别设置有发送缓存和接
  >
  > 受缓存，用来临时存放双通信的数据。发送发/接受方只要把发送/接受的数据放入缓存中，就可以去做
  >
  > 其它事情了，TCP 会在合适的时候发送/读取缓存中的数据，交付给下一层。

* 面向字节流

  > 虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交付下来的数据仅仅看
  >
  > 成是一连串的的无结构的字节流。TCP 中的流是指：流入到进程或从进程流出的字节序列。TCP不保证接
  >
  > 收方的应用程序所收到的应用程序和发送方的应用程序所发送的数据块具有对应大小的关系（根据接收方
  >
  > 的网络拥塞情况决定的），但接受到的字节流和发送的字节流是肯定一样的。

![TCP 流程](https://github.com/jogin666/blog/blob/master/resource/%E5%8D%8F%E8%AE%AE/images/TCP%20%E6%B5%81%E7%A8%8B.jpg)

图中的TCP 连接不是物理上的连接，而是逻辑上的连接，TCP报文被交付到 IP 层之后，加上IP首部，然后交付给

链路层然后加上链路层的首部和尾部之后，才能交付给物理层传输。



### 三、TCP协议的报文格式



![TCP 报文格式](https://github.com/jogin666/blog/blob/master/resource/%E5%8D%8F%E8%AE%AE/images/TCP%20%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.jpg)

* **源端口** ：发送方的端口号，在需要对方回信时选用，不需要时可用全0。

* **目的端口** ：接受方端口号，指明接收方的端口。

  > TCP 的分用功能是通过端口来实现的

* **序列号（seq）** ：占 4 字节，序号范围是[0-2^31-1],供32个字节，到最大值后又会重 0 开始，是按照 

  mod 2^32 运算的

  > TCP连接中的传送的字节流中的每一个字节都是按顺序编号的，传输字节流中的起始序号必须在连接立时
  >
  > 设置，首部中的序号字段值则是值本报文段所发送的第一个字节的序号。例如：一报文段的序号字段值是
  >
  > 300，携带的数据公有 100 个字节。则表明：该报文的第一个字节的序号是 301，最后的一个字节的序号
  >
  > 是 400，下一个报文段的序号值应为 401，这个字段的名称也称为 报文段序号 。

* **确认序列号（ack=seq+1）**：表示期望收到发送发下一个报文段的第一个数据字节的序号。 占 4 个字节。

* **数据偏移** ：指出 TCP 报文段的首部长度（不含数据部分的长度），占 4 个字节。

* **保留** ： 留给今后使用，目前置为 0 ，共占 6 位。

* **紧急 URG（URGent）**：指示报文中有紧急数据，应尽快传送（相当于高优先级别的数据）仅当 URG = 1时

  有效，发送方会把紧急数据插入到本报文段数据的最前面，需要与紧急指针字段搭配使用。

* **确认 ACK（ACKnowledgment）**：仅当 ACK = 1 时确认字段才有效，为 0 时，则表示无效，TCP 规定连接

  建立后，接受方所有传送的报文段的 ACK 的值都为 1。

* **推送 PSH（PuSH）**：当  PSH = 1 时，表名该报文段有推送标志，希望接受方在接受到报文时应尽快的将报

  文交付给应用程序，而不是放在缓冲区排队。

* **复位 RST（ReSeT）**：当 RST = 1 时，表示TCP 连接中出现严重差错（如主机崩溃），必须释放连接之后，再

  重新建立连接。RST = 1，也可以用来拒绝一个非法的报文段或者一个非法的打开连接。 

* **同步 SYN（SYNchronization）**：建立连接使用的同步序号。当 SYN = 1 而 ACK = 0 时，表示这是一个连接

  请求报文。当 SYN =1 而 ACK = 1 时，表示这是一个连接接受报文，接受确认接受连接。

* **终止 FIN（FINis）**：当 FIN = 1时，送方已完成报文传输，请求释放连接。

* **窗口** ：窗口值作为接受方让发送方设置其发送的窗口的依据（本次可以接受报文中数据的大小）。

* **检验和** ：校验数据是否出现差错。检验和字段检验的范围包括首部和数据两个部分。和 UDP 数据报检验一

  样，在检验时，需要加上 12 字节的伪首部，但 TCP 的协议号为 6（第四个字段）。

* **紧急指针** ：指出本文段中紧急数据的截止位置 ，仅当 URG = 1 时有效。

* **选项 **:  长度可变，最大为 40 个字节，当没有使用选项时， TCP 的首部长度是 20 个字节。

  > TCP 最初只规定了一种选项，即**最大报文段长度MMS（Maximum Segment Size）**，MMS 指的是最大
  >
  > 报文数据内容的数据大小，没有包括 TCP 的首部。



### 四、三次握手和四次挥手 

**4.1、三次握手**

![（图2）](https://img-blog.csdnimg.cn/20181113003428503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTY=,size_16,color_FFFFFF,t_70)

最开始的时候，客户端与服务端都是出于 **CLOSE** 状态，主动打开连接是客户端，被动打开连接是服务器。

* TCP 服务器进程会先创建控制块 TCB，时刻准备接受客户端进程的请求，此时服务器处于 **LISTEN(收听) **状

  态，等待客户端的连接请求。

* TCP 客户进程也是先建立传输控制块 TCB，然后才向服务器发送连接请求报文，报文首部的 **同部位 SYN = 1  **

  **同时选择一个初始序列号 seq=x**，此时 TCP 客户端进程进入一个 **SYN-SENT 状态(同步已发送状态)**，TCP 规

  定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但需要消耗掉一个序号。

* TCP 服务器收到请求报文之后，如果同意连接，则会送确认报文。确认报文中会把标志位设置  **ACK = 1，**

  **SYN = 1，确认号是 ack = x+1，同时也要初始化一个序列号 seq = y **，请注意这段报文也是不能懈怠数据4

  的，但同样需要消耗一个序列号，然后服务器会进入 **SYN-RCVD（同步收到）状态** 。

* 客户端收到服务器的确认报文之后，需要向服务器发送确认报文。在确认报文中设置标志位 **ACK = 1，ack= **

  **y+1，将自己的序列号设置为 seq = x+1** ，这时 TCP 进入连接状态，客户端进入 **ESTABLISHED（已建立连**

  **接）状态**，TCP标准规定，这时 ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。这种情况

  下，下一个发送的报文段的序号仍是 seq = x+1；

  

> 三次握手的主要目的是 ：防止信息不对等和连接超时（连接超时的脏连接）。首先非常明确的是两次握手是
>
> 最基本的。第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以
>
> 连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答，
>
> 客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。客户端只有确定了
>
> 自己能与服务端连接上才能开始发数据。所以两次握手肯定是最基本的。而第三次握手是为了防止已经失效
>
> 的连接请求报文段突然又传到服务端，因而产生脏连接。例如：客户端发出去的第一个连接请求由于某些原
>
> 因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但
>
> 是服务端不知道，仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手



**4.2、四次挥手**

![（图3）](https://img-blog.csdnimg.cn/20181113003438793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTY=,size_16,color_FFFFFF,t_70)



数据传输完毕后，双方都可释放连接。在释放连接时，客户端和服务器都是处于ESTABLISHED状态，然后客户端

主动关闭，服务器被动关闭。

* 客户端进程发出连接释放报文，并且停止发送数据。在释放数据报文首部，**FIN=1，其序列号为seq=u（等于**

  **前面已经传送过来的数据的最后一个字节的序号加1）**。然后，客户端进入**FIN-WAIT-1**（终止等待 1 ）状态。

   TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。

* 服务器收到连接释放报文，发出确认报文，在报文首部中 **ACK= 1，ack = u+1，并且带上自己的序列号 seq = **

  **v **，然后，服务端就进入了 **CLOSE-WAIT（关闭等待）状态** 。TCP服务器通知高层的应用进程，客户端向服务

  器的方向就释放了，这时候处于 **半关闭状态 **，即客户端已经没有数据要发送了，但是服务器若发送数据，客

  户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。

* 客户端收到服务器的确认请求报文之后，客户端就会进入 **FIN-WAIT-2（终止等待2）** 状态，等待服务器发送

  连接释放报文（在这之前可能需要接受服务器发送的最后的数据）。

* 务器将最后的数据发送完毕后，就向客户端发送连接释放报文，在报文的首部中**FIN=1，ack=u+1**。假定此时

  的序列号为 seq = w（由于处于半关闭状态，服务器发送了一些数据之后），服务器还需要重复上次发送过的

  确认号 ack = u+1。然后，服务器就进入了 **LAST -ACK（最后确认状态）**，等待客户端的确认。

* **ACK（最后确认）状态**，等待客户端的确认报文。

* 客户端收到服务器的连接释放报文值后，必须发出确认报文 **ACK = 1，ack = w+1 **，确认报文的序列号是

  seq = u+1（根据 TCP标准，前面发送的请求释放连接报文会消耗掉一个序列号），此时客户端就进入了 

  **TIME-WAIT（时间等待）状态**。注意此时TCP连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间

  后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。

* 务器在收到了客户端发出的确认报文之后，立即进入 **CLOSED** 状态。同样，撤销TCB后，就结束了这次的TCP

* 连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。



**4.3、TIME_WAIT状态 和 CLOSE_WAIT 状态**

* **TIME_WAIT** : 主动要求关闭的一方表示收到了对方的 FIN 报文，并发送出了 ACK 报文，进入TIME_WAIT 状

  态，等2MS L后即可进入到 CLOSED 状态。如果 FIN_WAIT_1 状态下，同时收到待 FIN 标识和 ACK 标识的报

  文时，可以直接进入TIME_WAIT状态，而无需经过 FIN_WAIT_2 状态（另一方没有数据还需要发送）。

* **CLOSE_WAIT**：被动关闭的机器收到对方请求关闭连接的 FIN 报文，在第一次 ACK 应答之后，马上进入

  CLOSE_WAIT 状态。这种状态其实标识在等待关闭，通知应用发送剩余数据，处理现场信息，关闭相关资源。

  

**4.4、为什么客户单最后还要等待 2MSL ？**

* 保证客户端发送的最后一个确认报文 ACK = 1 能够送达到服务器。 最后一个确认报文有可能哎网络中丢失，

  处于 LAST- ACK 状态的服务器在没有收到客户端的 FIN + ACK 确认报文之后，会超时重传 FIN + ACK 的释放

  连接的报文，服务端收到报文之后，重新发送 FIN + ACK 报文，重新启动 2MSL 计时器。如果报文丢失，就会

  重复上述步骤，直到服务器和客户端都进入 CLOSE 状态。

* 防止“已失效的连接请求报文段” 出现在本连接之中。客户端在发送最后一个报文段之后，在经过 2MSL的时间

  之后，就可以让本连接持续时间内产生的所有报文段都从网络中消失，这样就可以使下一个新的连接中不会出

  现旧的连接请求报文段。

**4.5、保活计时器**

* 除了时间等待计时器外，TCP 还设置了一个保活计时器，用来确保于客户端的连接是有效的，通常是设置两个

  小时，每次接受到报文之后，都会刷新保活计时器的计时，在过两个小时之后，仍没有收到报文，服务器就会

  发送一个探测报文，如果没有回应，之后每隔 75s，服务器就会发送一次探测报文，连续10次之后，服务会认

  定客户端出现故障，然后主动关闭这个连接。

  

> 四次挥手的目的是：服务次有可能还没有发送完数据，因此需要多一次确认。在建立连接的时候， 服务器在
>
> LISTEN 状态下，收到建立连接请求的SYN报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。 而关闭连
>
> 接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数
>
> 据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示
>
> 同意现在关闭连接，因此，己方 AC K和 FIN 一般都会分开发送，从而导致多了一次。





### 五、滑动窗口

TCP 滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个 TCP/IP 主机都支持全双工数据传输，

因此 TCP 有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP 使用肯定确认技术，其确认号指的是

下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发

送序列号为 1、2、3 的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以

窗口大小 3 发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降

低窗口大小为 2，每一次发送两个数据包。当接收方设备要求窗口大小为 0，表明接收方已经接收了全部数据，或

者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为 0 的确认，停止这一方向的数

据传输。当链路变好了或者变差了这个窗口还会发生变化的，并不是第一次协商好了以后就永远不变了。

滑动窗口协议，是 TCP 使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分

组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 只有在接收窗口向前滑

动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因

此这种协议又称为滑动窗口协议。

流量控制：端到端，接收端的应用层处理速度决定和网速无关，由接收端返回的 rwnd 控制。

**cwnd：发送端窗口( congestion window )**

**rwnd：接收端窗口（receiver window）**

此部分内容来源 ：<a href="https://blog.csdn.net/u013256816/article/details/84001583#comments">一文详解TCP</a>



### 六、拥塞控制

 拥塞控制： 发送端主动控制 cwnd ，   ①：慢启动（从 cwnd 初始为1开始启动，指数启动）；   ②：拥塞避免

(到达 ssthresh 后，为了避免拥塞开始尝试线性增长）；③：快重传（接收方每收到一个报文段都要回复一个当

前最大连续位置的确认，发送方只要一连收到三个重复确认就知道接收方丢包了，快速重传丢包的报文，并且 

TCP 会马上把拥塞窗口 cwnd 减小到1 ）；   ④：快恢复（直接从 ssthresh 线性增长）。

> 如果网络上的延时突然增加，那么 TCP 对这件事作出的应对只有重传数据，但是重传会导致网络的负担更 
>
> 重，于是会导致更大的延迟以及更多的丢包。于是这种情况就会进入恶性循环，被不断地放大。试想一下，
>
> 如果一个网络内有成千上万的 TC P连接都这样处理，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整
>
> 个网络。所以 TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此
>
> TCP 的设计理念是：TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每
>
> 个车都应该把路让出来，而不要再去抢路了。



慢启动：只有在 TCP 连接建立和网络出现超时时才使用。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传

输轮次所经历的时间其实就是往返时间 RTT。不过“传输轮次”更加强调：把拥塞窗口 cwnd 所允许发送的报文段

都连续发送出去，并收到了对已发送的最后一个字节的确认。另外，慢开始的“慢”并不是指 cwnd 的增长速率慢，

而是指在 TCP 开始发送报文段时先设置 cwnd = 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络

的拥塞情况），然后再逐渐增大 cwnd 。为了防止拥塞窗口 cwnd 增长过快引起网络拥塞，同时还需要设置一个慢

开始门限。

ssthresh 状态变量（如何设置ssthresh）。慢开始门限 ssthresh 的用法如下：

当 cwnd < ssthresh 时，使用上述的慢开始算法。

当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。

拥塞避免算法：让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加1，而

不是加倍。这样拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

![（图4）](https://img-blog.csdnimg.cn/20181113003453382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTY=,size_16,color_FFFFFF,t_70)



无论在**慢开始阶段**还是在**拥塞避免阶段**，只要发送方判断网络出现拥塞（**其根据就是没有收到确认**），就要把慢开

始门限 ssthresh 设置为出现拥塞是的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口 cwnd 重新设置为1

，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间

把队列中积压的分组处理完毕。

当TCP连接进行初始化时，把拥塞窗口 cwnd 置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而

使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。

在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。之后发送方每收到一个对新报文段的确认 ACK ，就把拥塞窗

口值加 1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口 cwnd 随着传输轮次按指数规律增

长。当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗

口按线性规律增长。假定拥塞窗口的数值增长到 24 时，网络出现超时（这很可能就是网络发生拥塞了）。更新后

的 ssthresh 值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始

算法。当 cwnd=ssthresh=12 时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一

个 MSS 的大小。强调：“拥塞避免” 并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能

的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。

如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的

某处被丢弃。这时，TCP马 上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值 ssthresh 减

半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的

是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。



![（图5）](https://img-blog.csdnimg.cn/20181113003501188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTY=,size_16,color_FFFFFF,t_70)



接收方收到了 M1 和 M2 后都分别发出了确认。现在假定接收方没有收到 M3 但接着收到了 M4 。显然，接收方不

能确认 M4，因为 M4 是收到的 **失序报文段**。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送

一次对 M2 的确认。但按照 **快重传算法** 的规定，接收方应及时发送对 M2 的重复确认，这样做可以让发送方及早

知道报文段 M3 没有到达接收方。发送方接着发送了 M5 和 M6。接收方收到这两个报文后，也还要再次发出对

M2 的重复确认。这样，发送方共收到了接收方的四个对 M2 的确认，其中后三个都是重复确认。**快重传算法 **还规

定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 M3，而不必继续等待 M3 设置的重

传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约 20%。



![（图6）](https://img-blog.csdnimg.cn/20181113003508697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNTY4MTY=,size_16,color_FFFFFF,t_70)

与 **快重传** 配合使用的还有 **快恢复算法**，其过程有以下两个要点：

当发送方连续收到三个重复确认，就执行 **“乘法减小”**算法，把慢启动门限 ssthresh 减半。这是为了预防网络发生

拥塞。请注意：接下去不执行慢开始算法。

由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口

cwnd 现在不设置为1），而是把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法

（“加法增大”），使拥塞窗口缓慢地线性增大。上图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。

区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。

发送方窗口的上限值 = Min [ rwnd, cwnd ]

当 rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。

当 cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。



### 七、差错控制

TCP使用 **差错控制** 来提供可靠性。差错控制包括以下的一些机制	①：检测和重传受到损伤的报文段；	②：重

传丢失的报文段；	③：保存失序到达的报文段直至缺失的报文到期；	④：及检测和丢弃重复的报文段。

TCP通过三个简单的工具来完成其差错控制：**检验和**、**确认**以及**超时**。



此部分内容来源：<a href="https://blog.csdn.net/u013256816/article/details/84001583#comments">一文详解TCP</a>





参考资料：

计算机网络（第7版） 谢希仁 编著。

<a href="https://blog.csdn.net/u013256816/article/details/84001583#comments">一文详解TCP</a>

<a href="https://baijiahao.baidu.com/s?id=1614404084382122793&wfr=spider&for=pc">关于TCP三次握手，这是我见过最好的解读了，通俗易懂</a>



